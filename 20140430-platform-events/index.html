<!DOCTYPE html>
<html>
<head>
	<title>Introducing Platform Events</title>
	<script src="//google-code-prettify.googlecode.com/svn/loader/run_prettify.js?skin=doxy"></script>
	<link type="text/css" rel="stylesheet" href="../common/blog.css">
	<style>
		a {
			color:           #3859a0;
			text-decoration: none;
		}

		a:hover, a:active, a:focus {
			color:           #2E3869;
			text-decoration: underline;
		}
	</style>
</head>
<body>
<div class="hs-migrated-cms-post df-blog">

<div class="pull-left">
	<img class="picture masthead" src="masthead.jpg">
</div>

<section id="introduction" class="flush-left">
	<H1 style="font-size: 2em; font-weight: bold; font-style:oblique ; padding-bottom:0; margin-bottom:0">Introducing Platform Events (Part 1)</H1>

	<p style="margin-top:0;">We've snuck an extra special treat into our latest release (<a href="https://github.com/dreamfactorysoftware/dsp-core/" target="_blank">version
		1.5</a>) of the DreamFactory Services Platform&trade;. This new morsel of awesome is our new
		<a href="https://github.com/dreamfactorysoftware/dsp-core/wiki/The-Platform-Event-System" target="_blank">Platform Event and Scripting System</a>. These two new
		built-in services (<code>/rest/system/event</code> and <code>/rest/system/script</code>) allows you, the developer, to a/synchronously listen for, and act
		upon, system events in real-time. That's a lot to digest so enjoy this introduction to the new event services.</p>
</section>

<section id="what-good-are-events" class="flush-left">
	<H2>What Good Are Events? Awesome Inside!</H2>

	<p>Since the dawn of humankind, events have been a part of our lives. Holidays, birthdays, gatherings, celebrations, keggers in Skred's cave; you name it! Unless you're
		some kind of hermit, you've probably attended an event or two. One annoying thing about events is that you always need a reminder (if you're not eidetic). As our
		technology has strengthened, our reminders, or notifications, have evolved as well. Now we can be notified of upcoming dates, events, parties, and/or cave happenings;
		from our device, social, and organizational networks. It seems to reason that someone would, at some point, blend these "reminders" into software architecture. I'm not
		sure which language had them first, but I remember them first in <a href="http://en.wikipedia.org/wiki/Object_Pascal" target="_blank">Delphi</a>, and then in
		<a href="http://en.wikipedia.org/wiki/Motif_(software)" target="_blank">Motif/X-Windows</a>. Pretty much all new software development systems after that had
		some sort of event system. But I digress.</p>

	<p>Events are important because having the system tell you when something is about to, or has, occurred; is a blessing in disguise. Once, long ago dear reader, applications
		were forced to <a href="http://en.wikipedia.org/wiki/Polling_(computer_science)" target="_blank">poll</a> for system changes. But we endured until our platforms
		embraced <a href="http://en.wikipedia.org/wiki/Event_(computing)" target="_blank">events</a>. These nuggets of system information, jam-packed full of goodies, allow you to
		build your applications more easily. What's that? Easy you say? Pssshaw!</p>

	<p>No, really, it is easier (if we did a good job implementing our event system ;) ). Consider a typical client-side developer (named Pat). Pat knows javascript and HTML5
		hands-down. But needs a specialized service that checks a remote server for additional authentication information. Perhaps for two-factor checks. But to build a service
		like that -- and incorporate it into the DreamFactory Services Platform&trade; -- can be a daunting task to they who are not one with PHP. This is where events
		rock.</p>

	<p>All Pat really needs to know is when someone is about to log in to the system. At that point the app can make the remote call and either allow or deny the operation.
		This login notification is one of many possible system <strong>events</strong>. The particular one that would be useful in this case is called
		<strong>session.login</strong>. So, Pat's app registers as a listener for this event (<strong>session.login</strong>). When it's triggered by a user logging on, the
		callback Pat registered is called and gives the application a chance to validate, augment, and/or deny the request. And this isn't the only way apps may consume events.
		The new <a href="https://github.com/dreamfactorysoftware/dsp-core/wiki/The-Platform-Event-System" target="_blank">Platform Event and Scripting System</a> supports
		handlers written in PHP and server-side javascript (more on this later). In addition, the system can notify applications via HTTP
		POST synchronously or asynchronously. Think about that for a sec... Ok, ready?</p>
</section>

<section id="how-do-it-know" class="flush-left">
	<H2>How Does It Work?</H2>

	<p>The DreamFactory Services Platform&trade; is architected in such a way that we can hook, inject, and augment REST API calls. This feature is
		implemented and demonstrated in the <strong>preProcess()</strong> and <strong>postProcess()</strong> methods of our base service and resource classes. We enhanced this
		system to dispatch events when REST API calls are processed. One of our major design goals was that the platform be merely a dispatcher of events, and not
		<strong>define</strong>
		them. Yes, the actions performed by the server trigger the events, but the names of these events are virtually ignored by the server.</p>

	<p>This is made possible by our use of <a href="https://github.com/wordnik/swagger-core" target="_blank">Swagger&trade;</a>
		for documenting our API. We've extended the <a href="https://github.com/wordnik/swagger-spec" target="_blank">standard Swagger&trade; schema</a>
		to include event name. This allows us to define events that are to be fired when specific API calls are made by clients.</p>
</section>

<section class="flush-left">
	<h2>All Platform Events Are Defined In Swagger&trade;</h2>

	<p>
		One of the great features of the DSP is the Live API/SDK. This is an application that is provided through the DSP admin application. At startup, it looks for any
		Swagger&trade; configuration files in the known resource and model paths. These files end in <code>.swagger.php</code>. They are aggregated and presented in a list
		by
		service. Once you expand a service, a list of REST operations provided by that service is shown. A user may then explore the documentation for each call. In
		addition,
		and this is cool part, the user can put all the arguments for any call into this application and the REST call will be made, and the results displayed.</p>

	<figure><img src="//raw.github.com/dreamfactorysoftware/dsp-blog-posts/master/20140430-platform-events/figure1.png" alt="Figure 1">
		<figcaption>Figure 1: The Live API/SDK option</figcaption>
	</figure>

	<p>Clicking the above option opens and loads the operations available by service. Clicking a service will expand and display the operations available. For instance,
		figure
		2 shows the new goodies that lie beneath the <code>system</code> service.</p>

	<figure><img src="//raw.github.com/dreamfactorysoftware/dsp-blog-posts/master/20140430-platform-events/figure2.png" alt="Figure 2">
		<figcaption>Figure 2: The list of operations for the new Event service</figcaption>
	</figure>

	<p>So not only can you manipulate events via the new service, we've also enhanced the Live API/SDK app to include the name of events that will fire for each call. In
		figure
		3, if a call is associated with an event, it will be displayed under the implementation notes.</p>

	<figure><img src="//raw.github.com/dreamfactorysoftware/dsp-blog-posts/master/20140430-platform-events/figure3.png" alt="Figure 3">
		<figcaption>Figure 3: Each POST to <code>/rest/system/event</code> fires a <code>system.events.create</code> event.</figcaption>
	</figure>

	<section class="callout warning-block">
		<h3>Pluralized Event Names</h3>

		<p>Because our REST API allows you to POST a single or a batch of data to a single call, there are separate events for each type. The difference is subtle, so
			double-check your code.</p>

		<p>For events that accept batched data, the service name is generally pluralized. For instance, <code>system.events.create</code>. Note the plural of the service:
			<strong>events</strong>.</p>

		<p>For targeted events, that is to say, a single resource is being created or retrieved by id, the name of the event reflects the operation type. For instance, an HTTP
			sent PATCH to <code>/rest/system/event/my.event.id</code> will generate a <code>system.event.update</code> event.</p>
	</section>
</section>

<section>
	<h2>Event Definitions</h2>

	<p>In the <code>*.swagger.php</code> (our standard Swagger&trade; service definition file extension) files, each operation that a service exposes has a section
		describing
		the operation. In figure 4, the <strong>GET</strong> operation of the <code>/rest/system/script</code> service.
		below.</p>

	<!--@formatter:off-->
	<figure>
		<pre class="prettyprint lang-php">
array(
	'method'           => 'GET',
	'summary'          => 'getScript() - Get the script with ID provided',
	'nickname'         => 'getScript',
	'type'             => 'ScriptResponse',
	<strong>'event_name' => '{api_name}.script.read',</strong>
	'parameters'       => array(
		array(
			'name'          => 'script_id',
			'description'   => 'The ID of the record to retrieve',
			'allowMultiple' => false,
			'type'          => 'string',
			'paramType'     => 'path',
			'required'      => true,
		),
	),
),
		</pre>
		<figcaption>Figure 4: The <code>/rest/system/script</code> GET operation definition.</figcaption>
	</figure>
	<!--@formatter:on-->

	<p>In between <strong>type</strong> and <strong>parameters</strong> is an element called <strong>event_name</strong>. This is the name of the event that is generated by
		this call. This element can accept either a single string, or array of event names.</p>
</section>

<section>
	<h2>Event Types and Placeholders</h2>

	<p>You'll also notice that the name of the event is not complete. We've used a <strong>placeholder</strong> for the API name to be inserted before the event is
		triggered.
		Utilizing this method, custom services created by developers can base their Swagger&trade; definition files on the service type they are creating. In the event
		above,
		<code>{api_name}</code> is the placeholder. In general, the value inserted into the placeholder for is the first part of the route to your service. The above API
		call,
		<code>/rest/system/script/{id}</code>, will have its placeholder with <code>system</code>. Thus the final event name generated will be
		<code>system.script.read</code>. </p>
</section>

<section>
	<h2>Types of Events</h2>

	<p>There are two distinct types of events generated by the platform. The events that are defined in the Swagger&trade; files are called <strong>Platform</strong>
		events. In
		addition to these, each REST API call generates a dynamic <strong>REST</strong> event.</p>

	<section>
		<h3>Platform Events</h3>

		<p>As stated above, these events are generated by any REST API call that has an event defined it the services' Swagger&trade; definition file. All calls except
			<strong>GET</strong> trigger the event <em>before</em> the service has processed the resource. This allows you to alter, augment, or deny the original
			request
			before it
			is passed to the service for handling. On <strong>GET</strong> calls, the event is triggered <em>after</em> the request has been processed, but not
			formatted
			for
			output. Again, allowing you alter the path, and/or the results, of the request.</p>

		<section>
			<h3>Resource Event Patterns</h3>

			<p>Platform events triggered by resource activity follow a simple CRUD naming convention regardless of the type of REQUEST. That is to say, some service will create
				resources with a POST, but will
				also update a resource with the same POST call. However, the events generated by the platform should always reflect the intention of the call, not the necessarily
				the verb used.</p>

			<section>
				<h4 class="list-header">Patterns</h4>

				<ul class="code-like">
					<li>{api_name}.<em><strong>resource</strong></em>.list</li>
					<li>{api_name}.<em><strong>resource</strong></em>.create</li>
					<li>{api_name}.<em><strong>resource</strong></em>.read</li>
					<li>{api_name}.<em><strong>resource</strong></em>.update</li>
					<li>{api_name}.<em><strong>resource</strong></em>.delete</li>
				</ul>
				<p><em><strong>resource</strong></em> will be replaced with the resource or service being targeted.</p>
			</section>
		</section>

		<section>
			<h3>Database Event Patterns</h3>

			<p>Platform events triggered by database activity follow a different naming convention. Database services trigger events that represent the DDL statement that will be
				or was, made. These are shown below.</p>

			<section>
				<h4 class="list-header">Patterns</h4>

				<ul class="code-like">
					<li>{api_name}.<em><strong>resource</strong></em>.describe</li>
					<li>{api_name}.<em><strong>resource</strong></em>.insert</li>
					<li>{api_name}.<em><strong>resource</strong></em>.select</li>
					<li>{api_name}.<em><strong>resource</strong></em>.update</li>
					<li>{api_name}.<em><strong>resource</strong></em>.delete</li>
				</ul>
				<p><em><strong>resource</strong></em> will be replaced with the resource or service being targeted.</p>
			</section>
		</section>
	</section>

	<section>
		<h3>REST Events</h3>

		<p>The second type of events generated by the platform are called <strong>REST</strong> events. These are generated for every call and are triggered before and
			after
			every
			call. They are also named with placeholders and behave the same was as Platform events in that manner.</p>

		<section>
			<h4 class="list-header">REST Event Patterns</h4>

			<ul class="code-like">
				<li>{api_name}.{action}.pre_process</li>
				<li>{api_name}.{action}.post_process</li>
			</ul>
			<p>This makes these event names very predicable and consistent with Platform events.</p>
		</section>
	</section>

	<section>
		<h3>Event Name Placeholders</h3>

		<p>Currently, the system recognizes, and dynamically replaces the following placeholders:</p>

		<section>
			<h4 class="list-header">System Values</h4>

			<ul class="code-like">
				<li>{api_name}</li>
				<li>{container}</li>
				<li>{folder_path}</li>
				<li>{file_path}</li>
				<li>{request_uri}</li>
				<li>{table_name}</li>
			</ul>
		</section>

		<section>
			<p>The following additional values are available to your event names for replacement. They represent all the parameters of the REST API request that was
				received and all have different sub-values. These correlate one-to-one with the Symfony HTTP Foundation's
				<a href="http://symfony.com/doc/current/components/http_foundation/introduction.html#request" target="_blank">Request</a> class's
				<a href="http://api.symfony.com/2.4/Symfony/Component/HttpFoundation/ParameterBag.html" target="_blank">ParameterBag</a> objects with the same name.</p>

			<h4 class="list-header">Additional Values</h4>

			<ul class="code-like">
				<li>{headers.*}</li>
				<li>{attributes.*}</li>
				<li>{cookie.*}</li>
				<li>{files.*}</li>
				<li>{query.*}</li>
				<li>{action.*}</li>
			</ul>
		</section>
	</section>
</section>

<section>
	<h3>Disabling Events</h3>

	<p>By default, all events and scripting services are enabled. You can disable any or all of the event types or script processing. The documentation for how to
		set up
		your
		DSP configuration to change these settings is available on the
		<a href="https://github.com/dreamfactorysoftware/dsp-core/wiki/The-Platform-Event-System#event-configuration-options" target="_blank">wiki</a>. </p>
</section>

<section id="how-can-i-use-them" class="flush-left">
	<H2>Right on... But How Do I Use Them?</H2>

	<p>The best way to learn the event system is to experience <em>all</em> events. To do this, there is a configuration setting called <code>dsp.log_all_events</code>. This is
		defaulted to <strong>FALSE</strong> in the release. Simply set this to <strong>TRUE</strong> and log out and back in. Your log file will now show every event as it is sent
		to the dispatcher. The call that triggered the event is also output to the log. Figure 5 is a snippet of three REST calls and the three events each call triggers.</p>

	<section>
		<figure>
		<pre class="prettyprint long-lines">
## Launchpad requests the list of services
app.DEBUG: Triggered: event "system.service.get.pre_process" triggered by rest/system/service  
app.DEBUG: Triggered: event "system.services.list" triggered by rest/system/service  
app.DEBUG: Triggered: event "system.service.get.post_process" triggered by rest/system/service  
			
## Then the DSP's configuration
app.DEBUG: Triggered: event "system.config.get.pre_process" triggered by rest/system/config  
app.DEBUG: Triggered: event "system.config.read" triggered by rest/system/config  
app.DEBUG: Triggered: event "system.config.get.post_process" triggered by rest/system/config  
			
## The roles are loaded for security checks
app.DEBUG: Triggered: event "system.role.get.pre_process" triggered by rest/system/role  
app.DEBUG: Triggered: event "system.roles.list" triggered by rest/system/role  
app.DEBUG: Triggered: event "system.role.get.post_process" triggered by rest/system/role  
		</pre>
			<figcaption>Figure 5: Three REST calls throwing nine events.</figcaption>
		</figure>

		<p>When a REST API call is received it goes through three essential stages: pre-processing, processing, and post-processing. Two of these stages are represented by the
			platform's REST events. These fire at the pre-processing and post-processing stage. They allow you to process any data before and after the request is processed.</p>

		<p>Sandwiched in between these events is the platform event for that REST API call. In the example above, the first platform event fired is
			<code>system.services.list</code>.</p>

		<section class="callout changed-block">
			<h4>Logging All Events</h4>

			<p>Remember, when <code>dsp.log_all_events</code> is enabled, ALL events are logged. Even events that have no handlers. In the snippet above there were nine events
				generated from three REST calls. However, there were no listeners for any of them so they were merely logged.</p>

			<p>If <code>dsp.log_all_events</code> is set to <strong>FALSE</strong> only events that are <em>dispatched</em>
				to handlers are logged.</p>

			<p>For events that accept batched data, the service name is generally pluralized. For instance, <code>system.events.create</code>. Note the plural of the service:
				<strong>events</strong>.</p>
		</section>
	</section>
</section>

<section id="conclusion" class="flush-left">
	<H2>So, There It Is</H2>

	<p>This post has been just a small sampling of the new Platform Event and Scripting System released with version 1.5 of the DreamFactory Services Platform&trade;. I am
		working on a follow-up to this blog which will include code samples and real-world examples of how this new feature can enhance your cool. Look for it in a few weeks.
		In the mean time, peruse the documentation on our newly <a href="https://github.com/dreamfactorysoftware/dsp-core/wiki" target="_blank">redesigned documentation/wiki</a>.
	</p>

	<p>In part 2 we will cover how to listen for events from the platform and touch on server-side scripting. A full guide on server-side scripting is forthcoming.</p>
</section>

</div>
</body>
</html>
